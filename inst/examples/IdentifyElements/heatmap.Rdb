<?xml version="1.0"?>
<article xmlns:r="http://www.r-project.org"
         xmlns:xi="http://www.w3.org/2003/XInclude">

<articleinfo>

<title>Finding SVG Nodes for a <r:func>heatmap</r:func> Plot in R</title>

<author><firstname>Duncan</firstname><surname>Temple Lang</surname>
  <affiliation><orgname>University of California at Davis</orgname>
               <orgdiv>Department of Statistics</orgdiv>
  </affiliation>
</author>
</articleinfo>

<section>
<title></title>

<para>
This explores how we can use the IdentifyDevice  to find out which 
primitive elements  that are drawn by R correspond to the elements in a plot.
We will use the <r:func>heatmap</r:func> function as our example as we have not yet
explored how that is constructed. 
The goal is to be able to post-process the SVG output from R
generated by a call to <r:func>heatmap</r:func> and to add tooltips
or some other interactive  capabilities.

</para>
<para>
We'll use the first example in the <r:func>heatmap</r:func> help page:
<r:plot img="heat.png"><![CDATA[
x  = as.matrix(mtcars)
rc = rainbow(nrow(x), start=0, end=.3)
cc = rainbow(ncol(x), start=0, end=.3)

hv = heatmap(x, col = cm.colors(256), scale="column",
               RowSideColors = rc, ColSideColors = cc, margins=c(5,10),
              xlab = "specification variables", ylab= "Car Models",
              main = "heatmap(Mtcars data, ..., scale = \"column\")")
]]></r:plot>
Note that there is a lot in this plot.
We can see the main data area is made up of polygons.
We have to other sequences of polygons on the left and top sides.
And then we have two dendograms adjacent to these. 
Finally we have observations and variable labels on the right and bottom sides 
and finally we have x and y labels and a title.
</para>
<para>
Next we use our IdentifyDevice.
<r:code>
library(RGraphicsDevice)
source("device.R")
dev = metaDev(keepCalls = TRUE)
hv = heatmap(x, col = cm.colors(256), scale="column",
               RowSideColors = rc, ColSideColors = cc, margins=c(5,10),
              xlab = "specification variables", ylab= "Car Models",
              main = "heatmap(Mtcars data, ..., scale = \"column\")")
dev.off()
</r:code>
We can now access  the system calls:
<r:code>
info = dev$info()
</r:code>
We can look at the primitive operations via the 
<r:func>names</r:func>  on the <r:var>info</r:var> list:
<r:code>
table(names(info))
<r:output><![CDATA[
line rect text 
 164  395   46 
]]></r:output>
</r:code>
We see that there are 395 calls to the "rect" (rectangle) primitive.
We have 32 observations in our data set and 11 variables.
This makes 352 rectangles for the main region.  
We also have a rectangle for each variable and each observation
in the sequence of rectangles on the sides of the plot.
This makes a total of 395 and so we have accounted for all of the rectangles.
</para>
<para>
The next thing we want to do is determine the order in which the
rectangles were drawn. We need to find the 352 data rectangles,
and then those in the horizontal strip, and finally those in the vertical 
strip. Let's get the rect elements:
<r:code>
rects = info[names(info) == "rect"]
</r:code>
Before we continue, let's also read the SVG document containing the generated plot:
<r:code>
library(XML)
doc = xmlParse("heat.svg")
</r:code>
We can then try to associate the primitive operations and the
graphical elements in the SVG document.
</para>
<para>
Within the SVG document, we are looking for
<xml:tag>path</xml:tag> and <xml:tag>g</xml:tag>
elements. We don't necessarily want all of them
as the cairo engine defines some
<xml:tag>path</xml:tag> and <xml:tag>g</xml:tag> elements
for use later on in the document. It does this for text, for instance.
<r:code>
gels = getNodeSet(doc, "//x:path|//x:g", "x")
</r:code>
Another way to think about this is that we want the top-level
<xml:tag>g</xml:tag> node and this will skip the
<xml:tag>defs</xml:tag> element.
So we can use
<r:code>
g = xmlRoot(doc)[["g"]]
</r:code>
Now we can find the <xml:tag>path</xml:tag> and <xml:tag>g</xml:tag>
elements within this sub-tree
<r:code>
gels = getNodeSet(g, ".//x:path|.//x:g", "x")
</r:code>
We end up with 612 nodes.
This is 7 more than in <r:var>info</r:var>.
Can we identify these 7 and so  establish the
connection between the primitives and the SVG elements?
</para>
<para>
Some of these <xml:tag>g</xml:tag> elements are just acting as a container
or group (hence the name <xml:tag>g</xml:tag>).
What we want is the collection of all <xml:tag>path</xml:tag> nodes
and also all <xml:tag>g</xml:tag> nodes which do not have
<xml:tag>path</xml:tag> children. We can get these with
<r:code>
gels  = getNodeSet(g, ".//x:path | .//x:g[not(child::x:path)]", "x")
</r:code>
Here we end up with 607 nodes. 
So we still have 2 too many.
</para>
<para>
We need to eliminate the <xml:tag>g</xml:tag> nodes that also have
<xml:tag>g</xml:tag> nodes as children:
<r:code>
gels  = getNodeSet(g, ".//x:path | .//x:g[not(child::x:g) and not(child::x:path)]", "x")
</r:code>
And now we have a match for the number of nodes and graphical primitive operations in
<r:var>info</r:var>.
We do know is that they are in the same order.
However, we have to figure out how these relate to the visual elements in
our display.
</para>

<para>
It turns out that <r:func>heatmap</r:func> first
draws the vertical strip of polygons on the left side of the plot,
i.e. corresponding to the observations. So there are 32 of these.
The function then draws
the strip for the variables at the top of the plot.
There are 11 of these.
How do we know this? We can explore the SVG file manually
and exclude pieces and view the resulting document to see what is missing.
However, another approach is to return to our top-most
<xml:tag>g</xml:tag> node and look at its children:
<r:code>
xmlSApply(g, xmlSize)
<r:output><![CDATA[
rect    g    g    g    g    g    g    g 
   0   32   11  352   45  124   40    1 
]]></r:output>
</r:code>
We see the rectangle (which we didn't draw, but libcairo did)
and then we see the next 395 elements are accounted for in the
first three <xml:tag>g</xml:tag> nodes.
So this tells us also that the rectangles for each combination
of variable and observation are in the 352 elements in the third <xml:tag>g</xml:tag>
node.
</para>
<para>
What is the order in which they are drawn?
Again, we can experiment manually. We can change the color on the first two <xml:tag>path</xml:tag> elements in
this third <xml:tag>g</xml:tag> node and make them, say, red.
When we reload the SVG document, we see that these are in the bottom left corner
and are vertically aligned, so  being drawn for each observation for a given variable.
If we change the 33rd <xml:tag>path</xml:tag> element in this group, we will see
the next column.
</para>
<para>
An alternative approach  to manually modifying the SVG document is to look
at the coordinates of the path. 
We can compute each node's <r:class>SVGPath</r:class> with
<r:code>
library(SVGAnnotation)
p = lapply(gels[44:76], as, "SVGPath")
</r:code>
Then we can look at the first two and the 
last two to see where they are located.
</para>
<para>
We now have enough information to put tooltips on the
rectangles in the heatmap.  For example, let's create the 
text for the tips as
<r:code>
tmp = expand.grid(a = colnames(mtcars), b = rownames(mtcars), stringsAsFactors = FALSE)
tips = sprintf("%s, %s %f", tmp$a, tmp$b, c(t(x)))
</r:code>
Now we can add them with
<r:code>
addToolTips(gels[44:395], tips)
</r:code>
Now let's save the SVG document to a new file:
<r:code>
saveXML(doc, "heatTips.svg")
</r:code>

</para>
<para>
The rectangles in the two strips on the sides of the plot
can be handled very similarly as
we know their nodes - <r:expr>gels[1:32]</r:expr>
and <r:expr>gels[33:43]</r:expr>.
</para>

</section>
<section>
<title>Finding the Text</title>
<para>
Let's see if we can find the SVG element corresponding to the title.
If we assume that the <r:func>heatmap</r:func> function
placed the title there with a call to the <r:func>title</r:func>
function, we can search for that in the list of primitive calls, i.e. <r:var>info</r:var>:
<r:code>
which(sapply(info, function(x) any("title" == x)))
</r:code>
This gives us one element - number 605, i.e. the last.
</para>

<para>
Let's find the labels on the two axes.
We can see if the <r:func>mtext</r:func> function was used to create these.
<r:code>
which(sapply(info, function(x) "mtext" %in% x))
<r:output><![CDATA[
text text 
 407  440 
]]></r:output>
</r:code>
So we now know which nodes correspond to these strings.
Which is which?  Again, we can look at the path
or alternatively we can look at the calls
<r:code>
dev$calls()[[407]]
</r:code>
We see the variable <r:var>xlab</r:var>.
We can even find the value of the string
from the first call
<r:code>
k = dev$calls()[[407]]
k[[1]]$xlab
</r:code>
Of course, there are alternative ways to get.
It is probably best to store the strings 
within the text graphics primitive in our IdentifyDevice.
</para>

<para>
What if we wanted to put tooltips or hyperlinks on
the strings within the labels, i.e. the row names and column names.
Let's examine all the text primitives but omit
the ones we already know correspond to the title
and the axes labels:
<r:code>
txt = info[-c(407, 440, 605)]
txt = txt[names(txt) == "text"]
</r:code>
This  gives us 43 nodes corresponding to the 11 + 32 names.
Now we can look at how they were called:
<r:code>
txt
</r:code>
We see that these are all generated from calls to <r:func>axis</r:func>
</para>
<para>
Since we want the SVG nodes corresponding to these, we can do the calculations
slightly differently.
<r:code><![CDATA[
i = 1:length(gels)
i = i[ !(i %in% c(407, 440, 605)) & names(info) == "text"]
]]></r:code>
Then we get the nodes with
<r:code>
gels[i]
</r:code>
</para>
</section>
<section>
<title>Putting It All Together</title>

<para>
Let's try to consolidate what we have learned into a function
<r:function><![CDATA[
getSVGHeatmap =
function(doc)
{
  if(is.character(doc))
    doc = xmlParse(doc)

  g = xmlRoot(doc)[["g"]]

  nr = xmlSize(g[[3]])
  nc = xmlSize(g[[2]])

  strings = g[[5]]

  structure(list(dataRectangles = xmlChildren(g[[4]]),
                 verticalStrip =  xmlChildren(g[[2]]),
                 horizontalStrip = xmlChildren(g[[3]]),
                 xText = strings[nc],
                 yText = strings[seq(nc + 2, length = xmlSize(g[[3]]))],
                 title = if(xmlSize(g) > 7) g[[xmlSize(g)]][[1]] else NULL,
                 axesLabels = list(x = strings[[nc + 1]], y = strings[[ length(strings) ]] ),
                 doc = doc),
             class = "SVGHeatmap")
}
]]></r:function>
This is not robust.
If any of the axes labels are suppressed, then there is an issue.
Similarly, if the dendograms are suppressed.
</para>
<para>
We can call this as
<r:code>
h = getSVGHeatmap("heat.svg")
</r:code>
and then we can use
<r:func>addToolTips</r:func>, etc.
to annotate the nodes.
Then we can <r:func>saveXML</r:func>
the document back to a file and view it.
</para>
<para>
Note that the xlink:title issue is present for the tooltips.
(See the <ulink url="http://www.omegahat.org/SVGAnnotation/FAQ.html"/>)

</para>



</section>
</article>